import { fabric } from "fabric";
import { v4 as uuidv4, parse as uuidParse } from "uuid";
import nacl from "tweetnacl";

import Dog from "../models/Dog.mjs";
import {
  convertMetadataStringToUint8Array,
  convertPNGDataURLToUint8Array,
  getMetadataFromUint8Array,
  addMetadataFromBase64DataURL,
} from "../utils/ImageUtil.mjs";
import ImageService from "./ImageService.mjs";
import { METADATA } from "../utils/constants.mjs";
import GeneService from "./GeneService.mjs";

describe("ImageService", () => {
  describe("generateDogPNGWithMetadata", () => {
    test("should return a Dog PNG with complete metadata", () => {
      const dog = GeneService.buildAdoptedDog();
      const canvas = new fabric.Canvas();

      const response = ImageService.generateDogPNGWithMetadata(dog, canvas);
      const pngUint8Array = convertPNGDataURLToUint8Array(response);

      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.GENE)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PUBLIC_KEY)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.SIGNED_HASH)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_1_GENE)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_2_GENE)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_2_PUBLIC_KEY)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_2_SIGNED_HASH)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_1_SIGNED_HASH)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_2_SIGNED_HASH)
      ).toBeDefined();
      expect(
        getMetadataFromUint8Array(pngUint8Array, METADATA.PARENT_MARRIAGE_HASH)
      ).toBeDefined();
    });
  });

  describe("isValidDogPNG", () => {
    test("should return false when there is no gene in metadata", () => {
      const dataURL = generateDataURLWithoutMetadata();
      const response = ImageService.isValidDogPNG(dataURL);

      expect(response).toBe(false);
    });

    test("should return false when there is no public key in metadata", async () => {
      const dogWithKey = await Dog.buildDog("hehe", "test");
      const dog = dogWithKey[0];

      let dataURL = generateDataURLWithoutMetadata();
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_gene",
        JSON.stringify(dog.gene)
      );

      const response = ImageService.isValidDogPNG(dataURL);

      expect(response).toBe(false);
    });

    test("should return false when there is no signed hash in metadata", async () => {
      const dogWithKey = await Dog.buildDog("hehe", "test");
      const dog = dogWithKey[0];

      let dataURL = generateDataURLWithoutMetadata();
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_gene",
        JSON.stringify(dog.gene)
      );
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_publicKey",
        dog.publicKey
      );

      const response = ImageService.isValidDogPNG(dataURL);

      expect(response).toBe(false);
    });

    test("should return false when there is an exception during parsing", async () => {
      let dataURL = generateDataURLWithoutMetadata();
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_gene",
        JSON.stringify("{invalid")
      );

      const response = ImageService.isValidDogPNG(dataURL);

      expect(response).toBe(false);
    });

    test("should return true for dogs generated by buildDog ", async () => {
      const dogWithKey = await Dog.buildDog("hehe", "test");
      const dog = dogWithKey[0];

      let dataURL = generateDataURLWithoutMetadata();
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_gene",
        JSON.stringify(dog.gene)
      );
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_publicKey",
        dog.publicKey
      );
      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_signedHash",
        dog.signedHash
      );

      const response = ImageService.isValidDogPNG(dataURL);

      expect(response).toBe(true);
    });
  });

  describe("generateApprovalPNG", () => {
    test("should return a PNG with hashed marriage ID", async () => {
      const canvas = new fabric.Canvas();
      const [parent1, key1] = await GeneService.buildAdoptedDog();
      const [parent2, key2] = await GeneService.buildAdoptedDog();

      let parent1DataURL = ImageService.generateDogPNGWithMetadata(
        parent1,
        canvas
      );
      const parent2DataURL = ImageService.generateDogPNGWithMetadata(
        parent2,
        canvas
      );

      const encoder = new TextEncoder();
      const uuid = encoder.encode(uuidv4());
      const parent1KeyUint8Array = convertPNGDataURLToUint8Array(key1);
      const parent1KeyString = getMetadataFromUint8Array(
        parent1KeyUint8Array,
        "pawgenics_secretKey"
      );

      const parent1Key = convertMetadataStringToUint8Array(parent1KeyString);
      parent1DataURL = addMetadataFromBase64DataURL(
        parent1DataURL,
        "pawgenics_signedMarriageId",
        nacl.sign(uuid, parent1Key)
      );

      const response = ImageService.generateApprovalPNG(
        parent1DataURL,
        parent2DataURL,
        key2
      );
      const pngUint8Array = convertPNGDataURLToUint8Array(response);

      expect(
        getMetadataFromUint8Array(pngUint8Array, "pawgenics_signedApprovalHash")
      ).toBeDefined();
    });
  });

  describe("generateProposalPNG", () => {
    test("should return a PNG with hashed approval", async () => {
      const dataURL = generateDataURLWithoutMetadata();
      const randomUuid = uuidParse(uuidv4());
      const keyPair = nacl.sign.keyPair();

      const response = ImageService.generateProposalPNG(
        dataURL,
        keyPair.secretKey,
        randomUuid
      );
      const pngUint8Array = convertPNGDataURLToUint8Array(response);

      expect(
        getMetadataFromUint8Array(pngUint8Array, "pawgenics_signedMarriageId")
      ).toBeDefined();
    });
  });

  describe("buildDogFromDataURL", () => {
    test("should return a Dog instance with correct metadata", () => {
      let dataURL = generateDataURLWithoutMetadata();

      const gene = { test: "hi" };
      const signedHash = new Uint8Array([1, 2, 3]);
      const publicKey = new Uint8Array([4, 5]);
      const parent1Gene = { parent1: "hi" };
      const parent2Gene = { parent2: "hi" };
      const parent2PublicKey = new Uint8Array([6, 7]);
      const parent1SignedHash = new Uint8Array([8, 9]);
      const parent2SignedHash = new Uint8Array([10, 11]);
      const parentMarriageHash = new Uint8Array([12, 13]);

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_gene",
        JSON.stringify(gene)
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_signedHash",
        signedHash
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_publicKey",
        publicKey
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parent1Gene",
        JSON.stringify(parent1Gene)
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parent2Gene",
        JSON.stringify(parent2Gene)
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parent2PublicKey",
        parent2PublicKey
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parent1SignedHash",
        parent1SignedHash
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parent2SignedHash",
        parent2SignedHash
      );

      dataURL = addMetadataFromBase64DataURL(
        dataURL,
        "pawgenics_parentMarriageHash",
        parentMarriageHash
      );

      const actualDog = ImageService.buildDogFromDataURL(dataURL);
      const expectedDog = new Dog(
        gene,
        signedHash,
        publicKey,
        parent1Gene,
        parent2Gene,
        parent2PublicKey,
        parent1SignedHash,
        parent2SignedHash,
        parentMarriageHash
      );

      expect(actualDog).toStrictEqual(expectedDog);
    });
  });

  describe("generatePrivateKeyDataPNG", () => {
    test("should return a data url with private key in its metadata", async () => {
      const keyPair = nacl.sign.keyPair();

      const response = await ImageService.generatePrivateKeyDataPNG(
        keyPair.secretKey
      );
      const pngUint8Array = convertPNGDataURLToUint8Array(response);

      expect(
        getMetadataFromUint8Array(pngUint8Array, "pawgenics_secretKey")
      ).toBeDefined();
    });
  });

  const generateDataURLWithoutMetadata = () => {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAABmJLR0QA/wD/AP+gvaeTAAAAxUlEQVR4nO3BMQEAAADCoPVPbQhfoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOA1v9QAATX68/0AAAAASUVORK5CYII=";
  };
});
